\documentclass{article}
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{listings}
\usepackage[margin=1in]{geometry}
\usepackage{xcolor}
\usepackage{gnuplot-lua-tikz}
\usepackage{subfig}
\usepackage{float}
\usepackage{siunitx}
\usepackage{color}
\usepackage{todonotes}

\lstset{
	language=C,
	basicstyle=\footnotesize\ttfamily,
	commentstyle=\footnotesize\ttfamily \color{black!60},
	numbers=left,
	numberstyle=\tiny,
	stepnumber=1,
	numbersep=5pt,
	frame=lines,
	tabsize=4,
	breaklines=true,
	breakatwhitespace=true,
	showspaces=false,
	captionpos=b
}

\pagestyle{fancy}
\lhead{ECE-C353}
\chead{Final Project}
\rhead{Sean Barag}
\cfoot{\thepage\ of \pageref{LastPage}}

\newcommand{\clst}[2]{
	\begin{center}
	\parbox{.6\textwidth}{
	\lstinputlisting[firstline=#1, lastline=#2, firstnumber=#1]{../src/work_crew.c}}
	\end{center}
}

\newcommand{\hlst}[2]{
	\begin{center}
	\parbox{.6\textwidth}{
	\lstinputlisting[firstline=#1, lastline=#2, firstnumber=#1]{../src/work_crew.h}}
	\end{center}
}

\newcommand{\ttt}[1]{\texttt{#1}}

\title{ECE-C353: Systems Programming \\ Final Project}
\author{Sean Barag \\ \ttt{<sjb89@drexel.edu>}}
\date{\today}

\begin{document}
\maketitle
\tableofcontents
\newpage
\section{Design}
The design for this multi-threaded recursive text search was based mostly on
provided code, but included heavy modification to prevent deadlocks.

\subsection{Header File}
All global instance, function, and type definitions were placed in the header
file~\ttt{work\_crew.h}, to improve the readability of the main source
file~\ttt{work\_crew.c}.
%
\hlst{1}{11}
%
These objects were declared globally, with the following intended meanings:
%
\begin{center}
\parbox{.85\textwidth}{
\begin{description}
	\item[MAX\_THREADS]{Maximum number of threads to possibly create.}
	\item[num\_threads]{Number of threads that have been spawned at any time.}
	\item[number\_sleeping]{Number of spawned threads that are currently sleeping.}
	\item[all\_done]{Boolean-like variable indicating if the entire origin directory has been searched.}
	\item[spawned]{Boolean-like variable indicating if other threads have been spawned yet.}
	\item[threads]{Pointer to array of type \ttt{pthread}, containing one element for each thread spawned.}
	\item[wake\_up]{Signal to wake threads up from sleeping.}
	\item[num\_sleeping]{Mutex protecting \ttt{number\_sleeping}.}
	\item[sleepers]{Pointer to array of mutexes protecting \ttt{number\_sleeping}.}
	\item[done]{Mutex protecting \ttt{all\_done}.}
\end{description}
}
\end{center}

In order to provide each thread with the appropriate information, a custom
datatype was created as shown below.
%
\hlst{13}{26}
%
Similar to previous assignments, the following pieces of information were
passed to each thread:
%
\begin{center}
\parbox{.85\textwidth}{
\begin{description}
	\item[threadID]{Integer identifier for the thread.  The first thread
	spawned will receive ID~0, and subsequent threads will receive~1,~2,
	$\ldots$ , \ttt{NUM\_THREADS} - 1.}
	\item[queue]{Pointer to the queue of files and directories to search.}
	\item[mutex\_queue]{Pointer to the mutex protecting the work queue.}
	\item[num\_occurrences]{Pointer to the integer representing the number of occurrences of the target string.}
	\item[mutex\_count]{Pointer to the mutex protecting~\ttt{num\_occurrences}.}
\end{description}
}
\end{center}
%
Additionally, a custom datatype was created to ease the process of generating
scriptable output.
%
\hlst{28}{35}
%
While these instance variables are fairly self-explanatory, they were created
with the following intended meanings:
%
\begin{center}
\parbox{.85\textwidth}{
\begin{description}
	\item[count]{The number of occurrences of the target string found by the returning function.}
	\item[time]{Amount of time required to execute the returning function.}
\end{description}
}
\end{center}

Finally, the non-main functions were declared:
%
\hlst{38}{40}
%
in which~\ttt{search\_for\_string\_serial} is the single-threaded
implementation,~\ttt{search\_for\_string\_mt} is the multi-threaded
implementation, and~\ttt{worker\_thread} is the function executed by each
thread.

\subsection{Main File}
\subsubsection{Main}
The main entry point for the search test is, as is expected, the~\ttt{main}
function, shown below.
%
\clst{24}{46}
%
The function first checks the command line arguments to ensure that it has
sufficient information to run~--- a string and a target directory.  If this
information is not provided, the usage syntax is printed to the screen and the
application exists.  Additionally, if the number of threads is not provided, it
defaults to eight.  Once this initial validation is complete, the single- and
multi-threaded implementations are executed, and a script-safe output in the
format of the following example:
%
\begin{table}[H]
	\centering
	\begin{tabular}{ccccc}
		                    & Threads & Single & Multi & Match \\
		Scriptable output:  & 8   & 3.292550   & 3.163284 & true \\
	\end{tabular}
\end{table}
%
This provides the number of threads, execution time for both the single- and
multi-threaded implementations, and whether or not the number of occurrences
for the two implementations matches in an easily-parsable format.  While this
was not a requirement for the assignment, it made the process of acquiring and
analyzing the resulting data much easier.

\subsubsection{Single-Threaded}
There were no appreciable changes made to the single-threaded implementation.
While the return type was changed to~\ttt{RET\_TYPE} and there were slight
modifications to the post-search code, the searching portions of the function
remained unmodified from the provided version.

\subsubsection{Multi-Threaded}
The multi-threaded approach to string search begins by allocating space for the
threads array and declaring and initializing the relevant mutexes.
%
\clst{194}{227}
%
Next, an array of mutexes for sleeping threads is created, as well as a series
of counters.  Finally, an instance of~\ttt{THREAD\_ARGS} is created and filled
with the appropriate values.

At this point in the execution, a timer is created and started, and an initial
thread is spawned.
%
\clst{229}{244}
%
After spawning the first thread, the multi-threaded control function simply
waits for all threads to return, at which point it stops the timer, calculates
the execution time, and prints its final search results and execution time.
%
\clst{245}{267}

\subsubsection{Worker Thread}

%This initial thread traverses the entire top level of the target directory
%without descending into any subdirectories, adding to the work queue all files
%and directories it reaches.  The reasoning for not spawning all of the threads
%initially is explained later in the code.
\section{Results}
\begin{figure}[H]
\centering
	\input{img/plot/multiThreadPlot.tex}
\end{figure}
\appendix

\section{Scripts}
\subsection{Data Acquisition}
\lstset{ language=bash }
\begin{center}
	\parbox{.85\textwidth}{
	\lstinputlisting{../data/getData.sh}}
\end{center}

\subsection{Data Processing}
\begin{center}
	\parbox{.85\textwidth}{
	\lstinputlisting{../data/processData.sh}}
\end{center}

\subsection{Data Calculation}
\lstset{ language=python }
\begin{center}
	\parbox{.85\textwidth}{
	\lstinputlisting{../data/calcData.py}}
\end{center}
\end{document}

