/* Lab 1: Histrogram generation
 * compile as follows: gcc -o histogram histogram.c -std=c99 -lpthread -lm
 */
#include <stdlib.h>
#include <stdio.h>
#include <sys/time.h>
#include <math.h>
#include <float.h>
#include <pthread.h>
#include <semaphore.h>

void run_test(int);
void compute_gold(int *, int *, int, int);
void compute_using_pthreads(int *, int *, int, int);
void *do_histogram(void *);
void check_histogram(int *, int, int);

#define HISTOGRAM_SIZE 500


/* structure for thread arguments */
typedef struct thread_args
{
	int threadID;
	int start;
	int count;

	int *src;
	int *dst;
	int *buf;
} THREAD_ARGS;

/* semaphore for the main histogram */
sem_t sem_histogram;

/* number of threads to create */
int num_threads = 8;

////////////////////////////////////////////////////////////////////////////////
// Program main
////////////////////////////////////////////////////////////////////////////////
int
main( int argc, char** argv)
{
	if(argc != 2 && argc != 3){
		printf("Usage: histogram <num elements> [num threads]\n");
		exit(0);
	}
	int num_elements = atoi(argv[1]);

	/* get number of threads from argv */
	if(argc == 3)
		num_threads = atoi(argv[2]);

	run_test(num_elements);
	return 0;
}

////////////////////////////////////////////////////////////////////////////////
//! Generate the histogram on the CPU and the GPU and compare results for correctness
////////////////////////////////////////////////////////////////////////////////
void run_test(int num_elements)
{
	float diff;
	int i;
	int *reference_histogram = (int *)malloc(sizeof(int) * HISTOGRAM_SIZE); // Space to store histogram generated by the CPU
	int *histogram_using_pthreads = (int *)malloc(sizeof(int) * HISTOGRAM_SIZE); // Space to store histogram generated by the GPU

	// Allocate memory for the input data
	int size = sizeof(int) * num_elements;
	int *input_data = (int *)malloc(size);

	// Randomly generate input data. Initialize the input data to be integer values between 0 and (HISTOGRAM_SIZE - 1)
	for(i = 0; i < num_elements; i++)
		input_data[i] = floorf((HISTOGRAM_SIZE - 1) * (rand()/(float)RAND_MAX));

	printf("Creating the reference histogram. \n");
	// Compute the reference solution on the CPU
	struct timeval start, stop;
	gettimeofday(&start, NULL);

	compute_gold(input_data, reference_histogram, num_elements, HISTOGRAM_SIZE);

	gettimeofday(&stop, NULL);
	float ref_time = (float)(stop.tv_sec - start.tv_sec + (stop.tv_usec - start.tv_usec)/(float)1000000);
	printf("CPU run time (reference) = %0.2f s. \n", ref_time);
	//check_histogram(reference_histogram, num_elements, HISTOGRAM_SIZE);

	// Compute the histogram using pthreads. The result histogram should be stored on the histogram_using_pthreads array
	printf("\n");
	printf("Creating histogram using %d pthreads. \n", num_threads);

	gettimeofday(&start, NULL);
	compute_using_pthreads(input_data, histogram_using_pthreads, num_elements, HISTOGRAM_SIZE);
	//check_histogram(histogram_using_pthreads, num_elements, HISTOGRAM_SIZE);

	gettimeofday(&stop, NULL);
	float thread_time = (float)(stop.tv_sec - start.tv_sec + (stop.tv_usec - start.tv_usec)/(float)1000000);
	printf("CPU run time (thread)    = %0.2f s. \n\n", thread_time);

	// Compute the differences between the reference and pthread results
	diff = 0.0;
   for(i = 0; i < HISTOGRAM_SIZE; i++)
		diff = diff + abs(reference_histogram[i] - histogram_using_pthreads[i]);

	printf("Difference between the reference and pthread results: %f. \n", diff);

	printf("Scriptable output:\t %d \t %0.2f \t %0.2f \n", num_elements, ref_time, thread_time);

	// cleanup memory
	free(input_data);
	free(reference_histogram);
	free(histogram_using_pthreads);

	pthread_exit(NULL);
}

/* This function computes the reference solution. */
void compute_gold(int *input_data, int *histogram, int num_elements, int histogram_size)
{
  int i;

  // Initialize histogram
  for(i = 0; i < histogram_size; i++)
			 histogram[i] = 0;

  // Bin the elements in the input stream
  for(i = 0; i < num_elements; i++)
			 histogram[input_data[i]]++;
}


// Write the function to compute the histogram using pthreads
void compute_using_pthreads(int *input_data, int *histogram, int num_elements, int histogram_size)
{
	int num_per_thread;
	int mod = num_elements % num_threads;
	num_per_thread = (num_elements - mod)/num_threads;

	THREAD_ARGS *t_args;	// reusable thread arguments structure

	pthread_t thread[num_threads];

	/* create semaphore for the histogram */
	sem_init(&sem_histogram, 0, 1);

	/* create two-dimensional array of buffer histograms */
	int **buffer = (int **)malloc(num_threads * sizeof(int *));
	for( int i = 0; i < num_threads; i++ )
		buffer[i] = (int *)malloc(histogram_size * sizeof(int));

	/* fill with all zeros */
	for( int i = 0; i < num_threads; i++ )
		for( int j = 0; j < histogram_size; j++ )
			buffer[i][j] = 0;

	for(int i = 0; i < num_threads; i++)
	{
		/* allocate new args structure */
		t_args = (THREAD_ARGS *)malloc(sizeof(THREAD_ARGS));

		/* fill args */
		t_args->threadID = i;
		t_args->start = num_per_thread * i;
		/* set number of elements.
		 * the last thread should handle the elements that remain from a
		 *   non-multiple of num_threads input */
		t_args->count = (i == (num_threads - 1) ? (num_per_thread + mod) : num_per_thread);

		t_args->src = input_data;
		t_args->dst = histogram;
		t_args->buf = buffer[i];

		/* spawn thread */
		if( (pthread_create (&thread[i], NULL, do_histogram, (void *)t_args)) != 0)
		{
			printf("Error: could not create thread! Exiting.\n");
			exit(-1);
		}
	}

	/* wait for all threads to return before proceeding */
	for(int i = 0; i < num_threads; i++)
		pthread_join( thread[i], NULL );
} // compute_using_pthreads

void *do_histogram(void *in_args)
{
	THREAD_ARGS *l_args = (THREAD_ARGS *)in_args;

	/* bin appropraite values */
	for(int i = l_args->start; i < (l_args->count + l_args->start); i++)
		l_args->buf[l_args->src[i]]++;

	/* lock semaphore */
	sem_wait(&sem_histogram);

	/* merge changes into global histogram */
	for( int i = 0; i < HISTOGRAM_SIZE; i++)
		l_args->dst[i] += l_args->buf[i];

	/* unlock semaphore */
	sem_post(&sem_histogram);

	pthread_exit(0);
}

void check_histogram(int *histogram, int num_elements, int histogram_size)
{
	int sum = 0;
	for(int i = 0; i < histogram_size; i++)
		sum += histogram[i];

	printf("Number of histogram entries = %d. \n", sum);
	if(sum == num_elements)
		printf("Histogram generated successfully. \n");
	else
		printf("Error generating histogram. \n");
}



